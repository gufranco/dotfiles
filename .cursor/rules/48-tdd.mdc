---
description: Test-Driven Development workflow patterns
globs: "**/*.test.ts,**/*.spec.ts,**/__tests__/**/*"
alwaysApply: false
---

# Test-Driven Development (TDD)

## The TDD Cycle
```
1. RED   → Write a failing test
2. GREEN → Write minimal code to pass
3. REFACTOR → Improve code, keep tests green
```

## Workflow

### 1. Before Implementation
- Understand the requirement completely
- Write test for expected behavior
- Run test to confirm it fails

### 2. During Implementation
- Write minimal code to make test pass
- Don't add functionality without a test
- Keep cycles short (minutes, not hours)

### 3. After Green
- Refactor for clarity and performance
- Run tests after every change
- Commit when tests pass

## Test Structure (AAA)
```typescript
it('should calculate total with tax', () => {
  // Arrange
  const items = [{ price: 100, quantity: 2 }];
  
  // Act
  const result = calculateTotal(items, 0.1);
  
  // Assert
  expect(result).toBe(220);
});
```

## Best Practices

### Good Tests
- One assertion per test (when practical)
- Descriptive names: `should_return_error_when_user_not_found`
- Test behavior, not implementation
- Fast execution (milliseconds)
- Isolated (no shared state)

### Test Priority
1. **Happy path** - Normal expected flow
2. **Edge cases** - Boundaries, empty inputs
3. **Error cases** - Invalid inputs, failures
4. **Integration** - Component interactions

### What NOT to Test
- Third-party library internals
- Framework behavior
- Private implementation details
- Trivial getters/setters

## Red Flags
- Tests that pass before code is written
- Tests that never fail
- Tests coupled to implementation
- Tests that require specific order
- Slow tests (> 1 second)

## Benefits
- Confidence in changes
- Documentation through tests
- Better design (testable = modular)
- Faster debugging (isolated failures)
- Safe refactoring
