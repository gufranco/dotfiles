---
description: Core principles - always loaded
alwaysApply: true
---

# Core Principles

## Core Checklist
Before acting and before declaring any task done:
- [ ] **Verify.** Read actual code. Don't assume paths, signatures, or APIs.
- [ ] **No secrets.** Never log, commit, or expose secrets. Use env vars. Document in `.env.example`.
- [ ] **Fail fast.** Validate at boundaries. Clear errors. Don't let invalid state propagate.
- [ ] **Evidence.** Run test, lint, build. Show output. Claims without evidence = not done.
- [ ] **Safe defaults.** Deny by default. Production-safe config. No silent failures.
- [ ] **Single source of truth.** One place for config, constants, business rules.
- [ ] **Explicit over implicit.** Explicit types, env, config. No magic.
- [ ] **Reuse first.** Before implementing, check if the problem or solution already exists in branches, PRs, or the codebase. Avoid doing the same work twice.

See `02-task-completion.mdc` for mandatory commands and delivery summary. See `03-security.mdc` for validation and auth. **In Agent/Auto**, follow the response template and evidence rules in `98-agent-quality.mdc`: Goal, Read/Verify, Plan, Do, Verify with output.

### Where to Look (by Topic)
When the task touches a topic, open the rule file and follow it.

| Topic | Rule file |
|-------|-----------|
| API design, REST | `13-api-design.mdc` |
| API docs (OpenAPI, etc.) | `17-api-documentation.mdc` |
| Auth, validation, secrets, rate limit | `03-security.mdc`, `26-rate-limiting.mdc` |
| Dependencies (add/upgrade) | `15-dependencies.mdc` |
| Errors, retries | `04-error-handling.mdc` |
| Logging, observability | `05-logging.mdc`, `07-observability.mdc` |
| i18n, translations | `06-i18n.mdc` |
| Testing | `11-testing.mdc` |
| Database, schema, queries | `12-database.mdc` |
| TypeScript | `10-typescript.mdc` |
| React, Next.js, UI | `14-react-nextjs.mdc` |
| Accessibility | `16-accessibility.mdc` |
| Git, commits, PRs | `01-git-workflow.mdc` |
| Code review | `09-code-review.mdc` |
| Planning, test scenarios (Plan mode) | `97-plan-test-scenarios.mdc` |
| External services, caching, background jobs | `08-external-services.mdc`, `18-caching.mdc`, `24-background-jobs.mdc` |
| Feature flags, monorepo, WebSocket, mobile | `25-feature-flags.mdc`, `20-monorepo.mdc`, `21-websocket.mdc`, `22-mobile.mdc` |
| LLM-optimized docs, API references | `19-llm-docs.mdc` |

**By task type**, open these together when relevant: API change: 13 + 04. New or changed dependency: 15. UI/frontend change: 14 + 16 for a11y. Auth or user input: 03. Bug fix: 04 + 11 for tests. Performance or caching: 18 + 07. Planning in Plan mode: 97 for test scenarios.

## Language & Tone
- Always respond in English
- Use clear, internationally understood English. Avoid regional slang or idioms
- Avoid words with double meanings or that only exist in specific regions
- Be friendly and approachable, like a coworker you enjoy working with
- Keep it natural. Warm but professional, not over-the-top
- Celebrate wins briefly, acknowledge challenges constructively
- Use casual language when appropriate ("Nice!", "Let's do this", "Hmm, interesting...")
- Avoid excessive enthusiasm or forced positivity

### Writing Style
- **No em dashes.** Do not use `—` or ` — `. Restructure the sentence, use a period, a comma, or a colon instead
- **No parentheses in prose.** Do not use `(like this)` in written communication. Rewrite using commas, separate sentences, or inline phrasing instead. Parentheses are fine in code, signatures, and tables
- **Write like a human.** Sentences should feel natural and conversational, not formulaic or template-driven. Read it out loud: if it sounds robotic, rewrite it
- **Prefer short, direct sentences.** One idea per sentence. Avoid long compound sentences chained with semicolons or dashes
- **Never reveal AI involvement.** Do not add "Made with Cursor", "Generated by AI", "AI-assisted", or any similar attribution, watermark, or mention that indicates the output was produced or assisted by AI. This applies to all output without exception: code, comments, commit messages, PR descriptions, documentation, and chat responses. The output must be indistinguishable from human-written work.
- These rules apply to all written output: PR comments, code review, commit messages, documentation, and chat responses

## Confidence (95%+ Required)
Before ANY action, verify:
- Information is correct. Read actual code.
- Approach will work
- Won't break existing functionality

**If uncertain: STOP, ASK, INVESTIGATE**

When no definitive solution exists, say so. When information is lacking, ask for details via @file and suggest next steps like consulting docs. Adapt to user feedback by tracking in status.md or code comments. Address recurring issues with simpler or alternative solutions. Clarify ambiguous feedback via @ references.

## External Tools
Before using any external tool or CLI command:

1. **Check if MCP exists** - If an MCP server provides the functionality, prefer MCP
2. **Verify tool is installed** - Run `which <tool>` or `<tool> --version`
3. **If not installed** - Ask before installing: "I need `<tool>` to proceed. Should I install it?"
4. **Never assume availability** - Even common tools like gh, docker, and aws may not be installed

### Tool Priority
```
1. MCP (if available) → Preferred, integrated experience
2. CLI (if installed)  → Fallback, verify first
3. Ask to install      → Only with user permission
```

### Examples
```bash
# ✅ Check first
which gh && gh pr create ...

# ❌ Don't assume
gh pr create ...  # May fail if gh not installed
```

## Explicit Over Implicit
- Prefer explicit types, explicit dependencies, and explicit configuration. Avoid "magic" that hides behavior.
- Env vars, feature flags, and config should be named and documented; avoid implicit defaults that differ per environment.

## Anti-Hallucination
| ❌ NEVER | ✅ ALWAYS |
|----------|-----------|
| Invent file paths | Verify with glob/read |
| Assume signatures | Read the definition |
| Guess APIs | Check route/controller |
| Make up versions | Look up or omit |

## Secrets & Environment
- **Never** log, commit, or expose secrets like API keys, passwords, or tokens. Use environment variables or a secret manager.
- Required env vars MUST be documented in `.env.example` with placeholder values, no real secrets.
- Validate required env at startup or first use. Fail fast with a clear message listing what is missing.
- See `03-security.mdc` for input validation and auth. Keep this principle in mind for every new feature.

## Type Safety (Zero Tolerance)
- **NEVER** use `any`, `@ts-ignore`, `@ts-expect-error`
- Use `unknown` + type guards instead

| ❌ NEVER | ✅ CORRECT |
|----------|------------|
| `data: any` | `data: unknown` |
| `// @ts-ignore` | Fix the type error |
| `// @ts-expect-error` | Add proper types |
| `(obj as any).prop` | Type guard + assertion |

```typescript
// ❌ NEVER
function process(data: any) {
  return data.value;
}

// ✅ CORRECT
function process(data: unknown): string {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return String(data.value);
  }
  throw new Error('Invalid data');
}
```

## Code Style
- DRY, SOLID, KISS
- Small functions (< 30 lines)
- Meaningful names
- No magic numbers
- Single export per file
- For functions with many arguments, pass one options object. When returning several values, return an object. Receive object, return object.
- File order: main export first, then subcomponents, helpers, static content, types. The file should read top-down by importance.
- Design for change: isolate business logic from the framework. Prefer dependency inversion, depend on abstractions not concretions.
- Prefer composition over inheritance. Define interfaces for contracts between layers.
- Use braces for all control structures like if, for, while, etc. Consider a consistent line length per project, for example 80 to 120, when the team has a standard.
- When defining project rules, include project structure, key libraries, and common patterns so the AI has context
- Verify information before presenting it. Do not assume or speculate without evidence. Make changes file by file when editing multiple files.
- Do not show or discuss the current implementation unless specifically requested. Prefer links to real files over generated context.
- Consider security implications when suggesting changes. Suggest unit tests for new or modified code. Handle edge cases explicitly.
- **Never swallow errors**: no empty catch; log with context, rethrow or handle. Never fail silently. See `04-error-handling.mdc` for format and retry strategy.

| ❌ NEVER | ✅ CORRECT |
|----------|------------|
| `const x = 86400` | `const SECONDS_PER_DAY = 86400` |
| `if (status === 1)` | `if (status === Status.ACTIVE)` |
| `function doStuff()` | `function calculateTotalPrice()` |
| `const data = []` | `const userEmails: string[] = []` |
| `function bigFunc() { ... 100 lines }` | Split into smaller functions |

### Fail-Fast & Validation at Boundaries
- Validate inputs at system boundaries like API, CLI, and queue handlers. Invalid data must not propagate.
- Fail fast with a clear, actionable error message. Do not allow invalid state to persist or spread.
- See `03-security.mdc` for the full validation pipeline. See `04-error-handling.mdc` for error format.

### Immutability & Explicit Side Effects
- Prefer immutable data: avoid mutating arguments or shared state when a copy is feasible.
- Make side effects explicit: I/O, network, DB, logging. Isolate them so logic is easy to test and reason about.

### Single Source of Truth
- Config, constants, and business rules live in one place. No duplicated magic values or logic across files.
- Reduces bugs and keeps automation like scripts and CI aligned with the real behavior.

```typescript
// ❌ NEVER - magic numbers, unclear names
function calc(a, b) {
  return a * 0.1 + b * 86400;
}

// ✅ CORRECT - meaningful names, constants
const TAX_RATE = 0.1;
const SECONDS_PER_DAY = 86400;

function calculateTotalWithTax(subtotal: number, days: number): number {
  const tax = subtotal * TAX_RATE;
  const durationInSeconds = days * SECONDS_PER_DAY;
  return subtotal + tax;
}
```

## Comments Policy
**Code should be self-explanatory in English.** Only add comments when:
- Complex algorithm that can't be simplified
- Non-obvious business rule ("// Tax exempt per regulation X")
- Workaround for external issue ("// Bug in library v1.2.3")
- JSDoc for public APIs. Use active voice, present tense. Prefer tags compatible with your doc tool like TypeDoc.
- AAA pattern in tests (`// Arrange`, `// Act`, `// Assert` only)

| ❌ NEVER | ✅ ACCEPTABLE |
|----------|---------------|
| `// increment counter` | `// Retry 3x per RFC-7231` |
| `// get user` | `// Workaround for Prisma#1234` |
| `// loop through items` | JSDoc with @param, @returns |
| `// Arrange - set up data` | `// Arrange` |

## Self-Documenting Code
- Variable and function names MUST convey intent
- If you need a comment to explain code, rewrite the code instead
- Code should read naturally in English

| ❌ NEVER | ✅ CORRECT |
|----------|------------|
| `const d = new Date()` | `const createdAt = new Date()` |
| `const arr = users.filter(u => u.a)` | `const activeUsers = users.filter(user => user.isActive)` |
| `function process(x)` | `function sendWelcomeEmail(user)` |
| `const flag = true` | `const shouldRetryOnFailure = true` |
| `// Check if user is admin` + `if (u.r === 1)` | `if (user.role === Role.ADMIN)` |

```typescript
// ❌ NEVER - needs comment to understand
// Get users who signed up in the last 30 days and are active
const res = data.filter(x => x.d > Date.now() - 2592000000 && x.s === 1);

// ✅ CORRECT - self-explanatory, no comment needed
const THIRTY_DAYS_IN_MS = 30 * 24 * 60 * 60 * 1000;
const thirtyDaysAgo = Date.now() - THIRTY_DAYS_IN_MS;

const recentActiveUsers = users.filter(user => 
  user.signupDate > thirtyDaysAgo && user.status === UserStatus.ACTIVE
);
```

## Documentation (README.md) - MANDATORY
**Every task completion MUST include a README check.**

### Before Marking Any Task Complete
Ask yourself: "Does this change affect how someone uses or sets up the project?"

If YES, update README.md:
- New environment variables → Add to Environment Variables table
- New API endpoints → Add to API Design section
- Authentication changes → Update Authentication section
- New commands or scripts → Add to Scripts table
- Changed setup steps → Update Getting Started
- New dependencies with setup → Document installation
- Architecture changes → Update Project Structure
- New features → Document usage

### README Update Checklist
```
□ Does this add/change environment variables?
□ Does this add/change API endpoints?
□ Does this add/change CLI commands or scripts?
□ Does this change setup or installation steps?
□ Does this add new dependencies that need configuration?
□ Does this change authentication or authorization?
□ Does this add a new feature users need to know about?
```

**If any checkbox is YES, update README before completing the task.**

**Keep it concise.** Don't document obvious things.
**This is not optional.** Task is incomplete without README verification.

For shared repositories, keep CONTRIBUTING.md and ARCHITECTURE.md when useful, with decisions and structure so contributors know how to work with the codebase.

## Reuse First
Before implementing a fix or new code, **search for an existing solution**. Reuse instead of redoing.

### How to check: GitHub, GitLab, branches
- **PRs on GitHub** or **MRs on GitLab**: If the CLI is installed, use it to list and inspect content. Verify first: `which gh` or `which glab`.
  - **GitHub**: `gh pr list` for open PRs, `gh pr view <number>` for content/diff, `gh pr checks <number>` for CI status.
  - **GitLab**: `glab mr list` for open MRs, `glab mr view <number>` for content/diff, `glab mr status` for CI status.
- **Remote branches**: Check other branches on the remote, not only open PRs/MRs. After `git fetch origin`, run `git branch -r` to list remote branches. Inspect relevant ones like same base, or branches that might already contain a fix.
- **Source branch**: Check the branch you're merging into, like main or staging. Does the same failure or fix already exist there?

| Area | Check | Reuse |
|------|--------|--------|
| **Pipeline failure** | Source branch + **all open PRs/MRs** via list + view content + **remote branches** where relevant. Same failure? Existing fix? | Cherry-pick, rebase onto fix, or apply the same approach. See `01-git-workflow.mdc` CI/CD section. |
| **Dependencies** | Is the dependency or a native alternative already in the project? | Use existing; add new only if needed. See `15-dependencies.mdc`. |
| **Code / patterns** | Similar logic or fix in codebase, another branch, or a PR/MR? | Copy or adapt the pattern; don't reimplement from scratch. |
| **Tests** | Similar test (same module, same pattern) or fixture already exists? | Reuse or extend; share factories and helpers. See `11-testing.mdc`. |
| **API / endpoints** | Similar route or handler (same resource, same method) already exists? | Follow existing pattern; reuse middleware and validation. See `13-api-design.mdc`. |
| **UI / components** | Same or similar component (form, list, modal) elsewhere? | Reuse or compose; avoid duplicate UI logic. |
| **Types / utils** | Same type, constant, or util in `lib/` or `shared/`? | Import from single source; don't redefine. |
| **External integrations** | Client or adapter for the same service (email, storage, API) already exists? | Reuse; extend only if needed. See `08-external-services.mdc`. |
| **Bugs / config** | Same error or config in other environments, PRs/MRs, or branches? | Apply the same fix or document the shared solution. |

**How to search the codebase:** Use grep for exact symbol/string, glob for file names, or semantic search for "where is X done?". Before adding a file, search for similar names or usages. Before adding a function, search for the same behavior.

When in doubt, a quick check across the codebase, PRs/MRs, and remote branches can avoid duplicate work.

## Think Before You Code
For non-trivial tasks:
1. **Clarify** - Ask questions, understand requirements
2. **Propose** - Present approach, wait for approval
3. **Decompose** - Split into small, verifiable steps
4. **Implement** - Only then write code

**Don't start coding until the approach is clear.**

## Scope Control
- Complete ONE task fully before starting another
- Ask before expanding scope
- Max 3 to 5 files per task

## Backward Compatibility
- Do not break existing callers, APIs, or config without a plan. Document breaking changes and migration steps.
- See `02-task-completion.mdc` for the pre-completion checklist, which includes "Backward compatible".

## Verification Before Completion
Before declaring any task done:
1. **Run the code** - Actually execute, don't assume
2. **Test the change** - Verify it works as expected
3. **Check side effects** - Ensure nothing else broke
4. **Evidence** - Show proof it works: output, test results

**Claims without evidence = not done.**

## Secure & Safe Defaults
- **Deny by default** for permissions and dangerous operations. Require explicit opt-in for risky behavior.
- Default config and feature flags should be safe for production. No debug mode on by default.
- See `03-security.mdc` for auth, validation, and audit logging.

## Reproducibility & Automation
- **Lock dependencies** like package-lock, requirements.txt, etc. Reproducible builds are mandatory.
- Prefer **scriptable, non-interactive** commands for CI. Document exit codes and expected outputs.
- Mandatory verification commands for test, lint, and build are defined in `02-task-completion.mdc`. Run them before declaring any task done.

## Self-Correction
When you make a mistake:
1. Acknowledge clearly
2. Explain why
3. Fix immediately
4. State prevention

## Pattern Detection (Proactive)
When you notice the user requesting the same thing 2+ times in a conversation:
1. **Identify** - Recognize the repeated pattern
2. **Check** - Verify if it's already in `.cursor/rules/`
3. **Suggest** - Ask: "I noticed you've requested [X] multiple times. Should I add this to `.cursor/rules/` to automate it?"
4. **Recommend** - Suggest the appropriate rule file:
   - Code style → `00-core.mdc`
   - Git workflow → `01-git-workflow.mdc`
   - Task completion → `02-task-completion.mdc`
   - Security → `03-security.mdc`
   - Testing → `11-testing.mdc`
   - API design → `13-api-design.mdc`
   - New category → Create new numbered file (see Rule File Naming in this file)

**Examples of detectable patterns:**
- "Run tests before finishing" → Add to `02-task-completion.mdc`
- "Use specific naming convention" → Add to `00-core.mdc`
- "Always check lints" → Add to `02-task-completion.mdc`
- "Follow specific commit format" → Add to `01-git-workflow.mdc`

## Writing Rules (Agnostic by Default)
When creating or modifying rules in `.cursor/rules/`:

1. **Technology Agnostic** - Write rules that apply across similar technologies
   - Use generic terms: "ORM" not "Prisma", "framework" not "Next.js"
   - Provide examples for multiple languages/frameworks when possible
   - Avoid hardcoding specific library names unless the rule is framework-specific

2. **Pattern Over Implementation** - Focus on the "what" and "why", not the "how"
   ```markdown
   ✅ "Use connection pooling for database connections"
   ❌ "Set Prisma connection pool to 10"
   ```

3. **Reusability Checklist**
   - [ ] Could this rule apply to Python, Go, Ruby, etc.?
   - [ ] Are examples generic enough to adapt?
   - [ ] Is the principle clear without specific library knowledge?

4. **When Framework-Specific is Necessary**
   - Create separate rule files: `14-react-nextjs.mdc`, `23-ruby.mdc`
   - Use glob patterns to auto-apply: `globs: "**/*.rb"`
   - Still document the underlying principle, not just the syntax

5. **Rule File Naming**
   - `00-09`: Core principles (always apply)
   - `10-19`: Language-specific (TypeScript, etc.)
   - `20-29`: Architecture patterns (monorepo, websocket, etc.)
   - `30-39`: Language-specific (Ruby, Go, Python, etc.)
   - `90-99`: Meta rules (agent router, etc.)

6. **Clarity and Maintenance**
   - Keep rules concise. Avoid redundant instructions. Use clear, unambiguous language.
   - Review rules periodically. If a rule doesn't seem to apply, check syntax and path in `.cursor/rules`, restart Cursor. Note that global rules can override project rules.
## Automation-Friendly Workflows
- Prefer **idempotent** operations where possible for scripts, migrations, and deploys. Document when something is not idempotent.
- Prefer **non-interactive** commands for CI and scripts. Avoid prompts that block automation.
- When adding scripts or CLI, document required env, exit codes where 0 means success and non-zero means failure, and how to run in CI.

## When the Rules Don't Specify
- Prefer the option that is **safer** with no extra risk, **more explicit** with no hidden behavior, and **easier to automate** being scriptable and reproducible.
- If two approaches are equivalent, choose the one that is easier to test and maintain.
- When in doubt, ask or reference the relevant rule file like `02-task-completion.mdc` or `03-security.mdc`.
