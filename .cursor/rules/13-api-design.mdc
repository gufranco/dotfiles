---
description: REST API conventions
globs: "**/routes/**,**/controllers/**,**/api/**"
alwaysApply: false
---

# API Design

See `00-core.mdc` (validation at boundaries, fail fast) and `04-error-handling.mdc` (error format). This file defines **URL design**, **request/response**, and **versioning**.

## Cross-Cutting Concerns
- Use middleware for logging, auth, and rate limiting instead of repeating logic in every handler.
- In microservices, consider an API Gateway for rate limiting, request transformation, and security filters (auth, validation) at the edge.

## URL Design
```
GET    /api/v1/{resource}           # List with pagination
POST   /api/v1/{resource}           # Create
GET    /api/v1/{resource}/{id}      # Get single
PATCH  /api/v1/{resource}/{id}      # Partial update
DELETE /api/v1/{resource}/{id}      # Delete
```

### Conventions
- Resources: nouns, plural (`/users`, `/orders`)
- Nesting: max 2 levels (`/users/:id/orders`)
- Actions: POST when CRUD doesn't fit (`/orders/:id/cancel`)

## HTTP Methods
| Method | Purpose | Idempotent |
|--------|---------|------------|
| GET | Read | ✅ |
| POST | Create | ❌ |
| PUT | Replace | ✅ |
| PATCH | Update | ❌ |
| DELETE | Remove | ✅ |

## Status Codes
| Code | When |
|------|------|
| 200 | Success (GET, PUT, PATCH) |
| 201 | Created (POST) |
| 204 | Deleted |
| 400 | Malformed request |
| 401 | Not authenticated |
| 403 | Not authorized |
| 404 | Not found |
| 409 | Conflict (duplicate) |
| 422 | Validation failed |
| 429 | Rate limited |
| 500 | Server error (never expose details) |

## Request Requirements
Every request MUST have:
- `Authorization: Bearer {token}` (except public endpoints)
- `Content-Type: application/json` (for POST/PATCH)

## Response Format

### Success
```json
{
  "data": { ... },
  "meta": {
    "requestId": "req_abc123",
    "timestamp": "2024-01-01T00:00:00Z"
  }
}
```

### Success with Pagination
```json
{
  "data": [...],
  "pagination": {
    "page": 1,
    "pageSize": 25,
    "totalItems": 150,
    "totalPages": 6
  },
  "meta": { ... }
}
```

### Error
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Human readable message",
    "details": [
      { "field": "email", "code": "INVALID", "message": "..." }
    ],
    "requestId": "req_abc123",
    "timestamp": "2024-01-01T00:00:00Z"
  }
}
```

## Response Headers
```typescript
response.headers.set('X-Request-ID', requestId);
response.headers.set('X-RateLimit-Limit', limit);
response.headers.set('X-RateLimit-Remaining', remaining);
response.headers.set('X-RateLimit-Reset', resetTimestamp);
```

## Pagination
```
?page=1&pageSize=25&sort=createdAt&order=desc
```
- Default pageSize: 25
- Max pageSize: 100
- Default sort: createdAt
- Default order: desc

## Filtering
```
?status=active&search=keyword&createdAfter=2024-01-01
```
All filters are AND conditions.

## Idempotency
POST requests SHOULD support `X-Idempotency-Key` header for safe retries.

## Versioning
- Version in URL path: `/api/v1/`
- Breaking changes require new version
- Old versions deprecated, not removed immediately

## GraphQL and Flexible APIs
- For GraphQL or other flexible query APIs, document and practice requesting only the fields needed to avoid over-fetch and unnecessary cost; prefer a typed/generated client when available.

## Webhook Endpoints

### Receiving Webhooks

#### Security
- Validate signature (HMAC-SHA256)
- Verify timestamp (reject if > 5 minutes old)
- Use idempotency key (event ID)

```typescript
function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const expected = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expected)
  );
}
```

#### Processing Pattern
```typescript
// ✅ Acknowledge immediately, process async
app.post('/webhooks/stripe', async (req, res) => {
  // 1. Verify signature
  if (!verifySignature(req)) {
    return res.status(401).json({ error: 'Invalid signature' });
  }
  
  // 2. Check idempotency
  const eventId = req.body.id;
  if (await isProcessed(eventId)) {
    return res.status(200).json({ received: true });
  }
  
  // 3. Queue for processing
  await queue.add('process-webhook', req.body);
  
  // 4. Acknowledge immediately
  res.status(200).json({ received: true });
});
```

#### Response Codes
| Code | Meaning | Sender Action |
|------|---------|---------------|
| 200 | Processed/Queued | Success |
| 400 | Invalid payload | Don't retry |
| 401 | Invalid signature | Don't retry |
| 429 | Rate limited | Retry with backoff |
| 500 | Server error | Retry with backoff |

### Sending Webhooks

#### Delivery Guarantees
- At-least-once delivery
- Exponential backoff on failure
- Dead letter queue after max retries

#### Retry Schedule
| Attempt | Delay |
|---------|-------|
| 1 | Immediate |
| 2 | 1 minute |
| 3 | 5 minutes |
| 4 | 30 minutes |
| 5 | 2 hours |
| 6+ | Dead letter |

#### Payload Structure
```json
{
  "id": "evt_abc123",
  "type": "work_order.completed",
  "timestamp": "2024-01-15T10:30:00Z",
  "data": {
    "workOrderId": "wo_xyz",
    "completedAt": "2024-01-15T10:30:00Z"
  }
}
```

#### Signing Outgoing Webhooks
```typescript
function signWebhook(payload: string, secret: string): string {
  const timestamp = Math.floor(Date.now() / 1000);
  const signature = crypto
    .createHmac('sha256', secret)
    .update(`${timestamp}.${payload}`)
    .digest('hex');
  
  return `t=${timestamp},v1=${signature}`;
}
```
