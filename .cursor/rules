# Cursor Rules

## Language
- Always respond in American English, regardless of the language the user uses

---

## Planning & Before Coding

### Pre-Implementation Requirements
- Study the relevant parts of the codebase before making changes
- Create a detailed plan and highlight uncertainties
- Verify implementation requirements with high certainty before proceeding
- If something is unclear, ask for clarification before proceeding
- Follow SOLID principles while maintaining pragmatism

### Approach
- Leverage existing patterns before creating new solutions
- Consult before introducing new dependencies or technologies
- Focus only on task-relevant code areas
- Never introduce new abstractions, helpers, utilities, or architectural patterns without explicit approval

### What to Avoid
- Guessing implementation details
- Starting implementation without understanding the full context
- Creating new patterns when existing ones work
- Over-engineering simple solutions

---

## Git Commits
When making commits, follow these conventions based on ~/.dotfiles/git/.gitmessage:

### Commit Message Format
```
<type>(<scope>): <subject>

<body>

<footer>
```

### Types (required)
- `feat`: A new feature
- `fix`: A bug fix
- `docs`: Documentation only changes
- `style`: Formatting, missing semicolons, etc (no code change)
- `refactor`: Code change that neither fixes a bug nor adds a feature
- `perf`: Code change that improves performance
- `test`: Adding missing tests or correcting existing tests
- `build`: Changes to build system or dependencies (npm, gradle, etc)
- `ci`: Changes to CI configuration files and scripts
- `chore`: Other changes that don't modify src or test files
- `revert`: Reverts a previous commit

### Scopes (optional, for this dotfiles repo)
- `zsh`: Shell configuration (aliases, functions, settings, paths)
- `brew`: Brewfile changes
- `install`: install.sh changes
- `git`: Git configuration
- `vim`: Vim/Neovim configuration
- `tmux`: Tmux configuration
- `eza`: eza configuration
- `bat`: bat configuration
- `kitty`: Kitty terminal configuration
- `gpg`: GPG/SSH configuration
- No scope for general changes

### Subject (required)
- Use imperative mood: "add" not "added" or "adds"
- Don't capitalize the first letter
- No period at the end
- Max 50 characters

### Body (optional)
- Wrap at 72 characters
- Explain WHAT and WHY, not HOW
- Separate from subject with a blank line
- Use bullet points if needed (- or *)

### Footer (optional)
- BREAKING CHANGE: <description>
- Closes #123, Fixes #456, Refs #789
- Co-authored-by: Name <email@example.com>

### Rules
1. Use `--no-gpg-sign` flag when GPG signing fails in terminal
2. Make atomic commits (one logical change per commit)
3. Group related changes together

### Examples
```
feat(eza): add configuration with Tokyo Night theme

fix(zsh): correct path for homebrew on Apple Silicon

refactor(install): simplify package installation logic

- Extract common functions to utilities
- Remove duplicate code blocks

docs: update README with installation instructions

chore(brew): update dependencies
```

---

## Branching Strategy

### Branch Naming Priority
1. **Tool-generated branches** (preferred): Use the branch name generated by project management tools
2. **Manual branches**: Follow the convention below when creating branches manually

### Tool-Generated Branch Formats
When a tool (Linear, Jira, etc.) generates the branch name, **always use it as-is**:

| Tool | Format | Example |
|------|--------|---------|
| **Linear** | `<username>/<issue-id>-<slug>` | `gufranco/eng-1234-user-authentication` |
| **Jira** | `<issue-key>-<summary>` | `ENG-1234-user-authentication` |
| **Shortcut** | `<username>/sc-<story-id>/<slug>` | `gufranco/sc-12345/user-authentication` |
| **GitHub Issues** | `<issue-number>-<slug>` | `123-fix-login-bug` |
| **GitLab Issues** | `<issue-number>-<slug>` | `123-fix-login-bug` |
| **Azure DevOps** | `<work-item-id>-<title>` | `1234-user-authentication` |
| **Asana** | `asana/<task-id>-<slug>` | `asana/1234567890-fix-bug` |
| **ClickUp** | `<task-id>-<slug>` | `abc123-user-authentication` |

### Creating Branches from Tools
```bash
# Linear (copy from issue sidebar or use CLI)
git checkout -b "gufranco/eng-1234-user-authentication"

# Jira (use Jira's "Create branch" button or copy suggested name)
git checkout -b "ENG-1234-user-authentication"

# GitHub CLI (creates branch linked to issue)
gh issue develop 123 --checkout

# GitLab (from merge request or issue)
git checkout -b "123-fix-login-bug"
```

### Manual Branch Naming (when no tool provides the name)
```
<type>/<ticket-id>-<short-description>
```

Types: `feature/`, `bugfix/`, `hotfix/`, `release/`, `chore/`

Examples:
- `feature/ENG-1234-user-authentication`
- `bugfix/ENG-5678-fix-null-pointer`
- `hotfix/ENG-9999-critical-security-patch`

### Branch Rules
- **Always prefer tool-generated branch names** for traceability
- Never commit directly to `main` or `staging`
- Keep branches short-lived (< 1 week ideally)
- Rebase feature branches on `staging` before PR
- Delete branches after merge
- Use `git pull --rebase` to avoid merge commits

### Syncing Branch with Issue
- Linear: Automatically links when using their branch format
- Jira: Use smart commits or branch naming with issue key
- GitHub: Use `gh issue develop` or reference in PR
- GitLab: Include issue number in branch name or MR description

---

## Pull Requests

### Title Format
```
<TICKET-ID>: <description>
```

Example: `ENG-3324: prevent advisory lock exhaustion by moving HTTP calls outside transactions`

### Creating PR with GitHub CLI
```bash
gh pr create \
  --title "<TICKET-ID>: <description>" \
  --body "<description with markdown>" \
  --assignee "@me" \
  --base staging
```

### After Creating
- Add Copilot as reviewer manually via GitHub UI (not supported via CLI)
- Base branch is always `staging` unless specified otherwise

### PR Description Template
Include these sections in the body:
- **Summary**: Brief description of what the PR does
- **Problem**: What issue this solves
- **Solution**: How it was solved (numbered list of changes)
- **Files Changed**: Categorized list of modified files
- **Testing**: How it was tested
- **Linked Issue**: `Fixes <TICKET-ID>`

### Example PR Description
```markdown
## Summary
Prevent advisory lock exhaustion in the database by refactoring HTTP calls.

## Problem
HTTP calls inside transactions were causing advisory locks to be held for too long.

## Solution
1. Refactored HTTP calls outside transactions
2. Added retry logic with exponential backoff
3. Configured connection pool timeouts

## Files Changed
- `src/services/payment.ts` - moved HTTP calls
- `src/config/database.ts` - updated pool settings

## Testing
- Unit tests for retry logic
- Load testing with 1000 concurrent requests

## Linked Issue
Fixes ENG-3324
```

---

## Code Review

### As Author
- Self-review before requesting reviews
- Keep PRs small (< 400 lines ideally, max 1000)
- Respond to all comments, even if just "Done"
- Don't take feedback personally

### As Reviewer
- Review within 24 hours (business hours)
- Be constructive, not critical
- Prefix comments with intent:
  - `nit:` - Minor, non-blocking suggestions
  - `suggestion:` - Optional improvement
  - `question:` - Seeking clarification
  - `issue:` - Must be addressed before merge
  - `praise:` - Highlight good practices
- Approve with comments if only nits remain

### What to Look For
- Logic errors and edge cases
- Security vulnerabilities
- Performance implications
- Test coverage
- Documentation updates needed
- Breaking changes

---

## Code Style

### General Principles
- Write clear, simple solutions over clever ones
- Follow existing patterns in the codebase
- Prefer DRY, SOLID, and KISS principles
- Consider architectural impact before making changes
- Work within established patterns before suggesting alternatives

### Implementation Rules
- Only modify code that is directly necessary for the task
- Do not change formatting, style, or syntax of existing code unless required
- Preserve exact formatting and style of surrounding code
- Match indentation, bracket placement, and stylistic choices of the file
- Never run formatters/linters on code you did not create as part of the task
- All new code must match import order, naming conventions, and style of the repository

### Shell Scripts Specific
- Use `__` prefix for internal helper functions
- Keep configurations organized with clear section headers using `#` comments

### What NOT to Do
- Modify unrelated code while fixing a bug
- "Improve" code style of existing files
- Add unnecessary abstractions
- Refactor without explicit request

---

## Naming Conventions

### General Rules
- Use descriptive, intention-revealing names
- Avoid abbreviations (except well-known: `id`, `url`, `api`)
- Be consistent within the codebase
- Longer names for larger scopes

### By Language
| Element | JavaScript/TS | Python | Go |
|---------|--------------|--------|-----|
| Variables | camelCase | snake_case | camelCase |
| Constants | SCREAMING_SNAKE | SCREAMING_SNAKE | camelCase |
| Functions | camelCase | snake_case | CamelCase (exported) |
| Classes | PascalCase | PascalCase | PascalCase |
| Files | kebab-case | snake_case | lowercase |

### Boolean Naming
- Prefix with: `is`, `has`, `can`, `should`, `will`
- Examples: `isActive`, `hasPermission`, `canEdit`

### Function Naming
- Verbs for actions: `get`, `set`, `create`, `update`, `delete`, `fetch`, `calculate`
- Example: `getUserById`, `calculateTotalPrice`

---

## Shell Scripts
- Use `#!/usr/bin/env bash` shebang
- Quote variables: `"$VAR"` not `$VAR`
- Use `[[ ]]` for conditionals in bash
- Use `command -v` instead of `which` for checking command existence

---

## Testing

### Test Pyramid
- Unit tests: Fast, isolated, mock dependencies (70%)
- Integration tests: Test component interactions (20%)
- E2E tests: Critical user journeys only (10%)

### AAA Pattern
Structure all tests with clear sections:
```
// Arrange - Set up test data and conditions
// Act - Execute the code being tested
// Assert - Verify the results
```

### Guidelines
- Write tests before fixing bugs (regression prevention)
- Test behavior, not implementation
- Use descriptive test names: `should_return_error_when_user_not_found`
- One assertion per test (when practical)
- Avoid testing private methods directly
- Mock external services, not your own code
- Use faker libraries for test data generation (avoid hardcoded values)

### Test Isolation
- Every test must be fully isolated
- Tests must not share state with other tests
- Never connect to real databases or external services in tests
- Always use mocks, fakes, or test-specific utilities
- Avoid `beforeAll`/`beforeEach` unless required by existing patterns
- Clean up test data after each test

### File Naming
- Name test files after the module they test: `moduleName.test.ts`, `moduleName.spec.ts`
- Keep test files alongside source files or in a dedicated `__tests__` directory

### Coverage
- Aim for 80%+ coverage on critical paths
- 100% coverage is not a goal; meaningful tests are
- New code should not decrease overall coverage
- Run tests to confirm they pass before completing the task

---

## Input Validation

### Principles
- Validate all user inputs at the entry point (controller/handler layer)
- Follow existing validation patterns in the codebase
- Return appropriate HTTP status codes (400 for validation, 401 for auth, etc.)
- Log validation failures with appropriate context

### What to Validate
- Required fields presence
- Data types and formats
- Value ranges and lengths
- Business rule constraints
- File uploads (type, size, content)

### Error Responses
- Return clear, actionable error messages
- Include field-level errors when applicable
- Never expose internal implementation details
- Use consistent error response format across the API

---

## Error Handling

### Principles
- Fail fast, fail loudly in development
- Fail gracefully in production
- Never swallow exceptions silently
- Include context in error messages
- Use custom error types for domain errors
- Use existing error classes before creating new ones
- Extend existing error types if needed

### Error Responses
- Follow existing API response format
- Never expose internal error details to clients in production
- Sanitize error messages appropriately
- Include request context in logs (userId, requestId, etc.)

---

## Logging

### Log Levels
- `ERROR`: Application errors requiring attention
- `WARN`: Unexpected but handled situations
- `INFO`: Significant business events
- `DEBUG`: Detailed diagnostic information (dev only)

### What to Log
- Request/response for external APIs (sanitized)
- Authentication events (login, logout, failures)
- Business-critical operations
- Performance metrics for slow operations

### What NOT to Log
- Passwords, tokens, PII
- Full credit card numbers
- Health check endpoints (unless failing)
- High-frequency events without sampling

---

## Security

### Secrets Management
- NEVER commit secrets, tokens, or credentials
- Use environment variables or secret managers
- Add sensitive patterns to `.gitignore`
- Rotate compromised secrets immediately
- Use `git-secrets` or `gitleaks` for pre-commit hooks

### Secure Coding
- Validate and sanitize all inputs
- Use parameterized queries (prevent SQL injection)
- Escape output (prevent XSS)
- Implement proper authentication and authorization
- Use HTTPS everywhere
- Keep dependencies updated (use Dependabot/Renovate)
- Follow principle of least privilege

### Sensitive Files to Never Commit
- `.env`, `.env.*` (except `.env.example`)
- `*.pem`, `*.key`, `*.p12`
- `credentials.json`, `serviceAccount.json`
- `id_rsa`, `id_ed25519` (private keys)

---

## Documentation

### Code Comments
- Explain WHY, not WHAT (code shows what)
- Document non-obvious decisions
- Keep comments updated with code
- Use TODO/FIXME with ticket numbers: `// TODO(ENG-1234): refactor this`
- Delete commented-out code

### README Requirements
- Project description and purpose
- Prerequisites and dependencies
- Installation/setup instructions
- Configuration options
- Usage examples
- Contributing guidelines link

### Architecture Decision Records (ADR)
For significant decisions, document:
- Context: What is the issue?
- Decision: What was decided?
- Consequences: What are the trade-offs?

---

## API Design

### REST Conventions
- Use nouns for resources: `/users`, `/orders`
- Use HTTP methods correctly:
  - `GET`: Read (idempotent)
  - `POST`: Create
  - `PUT`: Full update (idempotent)
  - `PATCH`: Partial update
  - `DELETE`: Remove (idempotent)
- Use plural nouns: `/users` not `/user`
- Nest for relationships: `/users/{id}/orders`

### HTTP Status Codes
- `200`: Success
- `201`: Created
- `204`: No Content (successful DELETE)
- `400`: Bad Request (client error)
- `401`: Unauthorized (not authenticated)
- `403`: Forbidden (not authorized)
- `404`: Not Found
- `409`: Conflict
- `422`: Unprocessable Entity (validation error)
- `500`: Internal Server Error

### Versioning
- Use URL path: `/api/v1/users`
- Never break existing versions
- Deprecate with headers and documentation

---

## Type Safety (TypeScript)

### Guidelines
- Ensure all TypeScript types are properly defined and used
- Avoid `any` types; use `unknown` with type guards when necessary
- Leverage existing type definitions from shared packages
- Ensure type safety in all database queries and API responses
- Resolve all TypeScript errors before completing the task

### Type Guards
```typescript
// Prefer type guards over type assertions
function isUser(obj: unknown): obj is User {
  return typeof obj === 'object' && obj !== null && 'id' in obj;
}
```

---

## Database

### ORM Usage
- Always use ORM's native methods for database operations
- Query Builder or raw SQL only when ORM doesn't support the operation
- State explicitly when using non-ORM approaches and why
- Use eager/lazy loading appropriately

### Migrations
- Always use migrations (never manual DDL in production)
- Migrations must be reversible when possible
- One logical change per migration
- Name descriptively: `20240115_add_email_index_to_users`
- Test migrations on production-like data
- Never modify migrations already applied to production
- Backup data before destructive migrations (DROP, DELETE, etc.)
- Document migration rationale in name or description

### Query Guidelines
- Use indexes for frequently queried columns
- Avoid `SELECT *`; specify columns
- Use pagination for large datasets
- Avoid N+1 queries (use eager loading)
- Use transactions for related operations
- Set query timeouts
- Keep transactions as short as possible
- Select only required fields

### Naming
- Tables: plural, snake_case (`user_accounts`)
- Columns: singular, snake_case (`created_at`)
- Indexes: `idx_<table>_<columns>`
- Foreign keys: `fk_<table>_<referenced_table>`

---

## Performance

### General Guidelines
- Measure before optimizing (profile first)
- Optimize hot paths, not everything
- Cache expensive operations
- Use lazy loading for non-critical resources
- Implement pagination for lists

### What to Avoid
- Premature optimization
- N+1 database queries
- Blocking I/O in async contexts
- Memory leaks (event listeners, closures)
- Synchronous operations for large datasets

---

## Environment & Configuration

### 12-Factor App Principles
- Store config in environment variables
- Keep dev/staging/prod as similar as possible
- Never hardcode environment-specific values

### Environment Files
- `.env.example`: Template with all vars (commit this)
- `.env`: Local development (never commit)
- `.env.test`: Test environment config

### Configuration Hierarchy
1. Environment variables (highest priority)
2. Config files
3. Default values in code (lowest priority)

---

## Dependencies

### Management
- Pin exact versions in lock files
- Update dependencies regularly (weekly/monthly)
- Review changelogs before major updates
- Use automated tools (Dependabot, Renovate)

### Evaluation Criteria for New Dependencies
- Actively maintained (recent commits)
- Good documentation
- Reasonable bundle size
- License compatibility
- Security track record
- Community adoption

### Avoid
- Dependencies for trivial operations (left-pad syndrome)
- Multiple libraries for same purpose
- Unmaintained packages (> 1 year without updates)

---

## Versioning

Follow [SemVer](https://semver.org/): `MAJOR.MINOR.PATCH`

- **MAJOR**: Breaking changes (incompatible API changes)
- **MINOR**: New features (backwards compatible)
- **PATCH**: Bug fixes (backwards compatible)

### Pre-release
- Alpha: `1.0.0-alpha.1` (unstable, incomplete)
- Beta: `1.0.0-beta.1` (feature complete, may have bugs)
- RC: `1.0.0-rc.1` (release candidate)

### Changelog
- Keep a `CHANGELOG.md` following [Keep a Changelog](https://keepachangelog.com/)
- Sections: Added, Changed, Deprecated, Removed, Fixed, Security

---

## Task Completion

### Pre-Completion Checklist
- [ ] Changes maintain system integrity and backward compatibility
- [ ] Implementation matches existing patterns in the codebase
- [ ] No unnecessary formatting or style changes to existing code
- [ ] All errors properly handled and logged
- [ ] Input validation implemented for user-facing endpoints
- [ ] TypeScript/language compilation passes without errors
- [ ] Database queries optimized (no N+1, appropriate eager loading)
- [ ] No sensitive data logged or exposed
- [ ] Tests written and passing
- [ ] Documentation updated if needed

### Delivery Summary
After completing a task, provide:
1. **Modified files**: List of all changed files
2. **Changes description**: What was done and why
3. **Tests**: Tests created/modified and coverage confirmation
4. **Risks/Notes**: Any concerns, edge cases, or follow-up items

### Version Control Behavior
- Create branches following the branching strategy
- Make atomic commits (one logical change per commit)
- Never commit sensitive data or credentials
- User handles final commit and push unless specified otherwise
