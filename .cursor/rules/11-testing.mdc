---
description: Testing standards
globs: "**/*.test.ts,**/*.spec.ts,**/__tests__/**"
alwaysApply: false
---

# Testing

See `00-core.mdc` and `02-task-completion.mdc` for evidence and mandatory test run. When planning a task, generate test scenarios per `97-plan-test-scenarios.mdc`. This file defines **test philosophy**, **mocks policy**, and **coverage**.

## Documentation
Consult before implementing. See `19-llm-docs.mdc` for the full reference.
- **Vitest**: [llms.txt](https://vitest.dev/llms.txt)
- **Jest**: https://jestjs.io/docs/getting-started
- **Playwright**: https://playwright.dev/docs/intro

## Philosophy
Tests should verify real behavior, not mock behavior.

## Priority
1. **Integration** (preferred) → Real database, real services
2. **E2E** → Full user flows
3. **Unit** (fallback) → Pure functions only

## Mocks Policy (STRICT)

### ✅ ALLOWED to Mock
- External APIs (Stripe, Resend, etc.)
- Time/Date (use fake timers)
- Randomness (`crypto.randomUUID()`)

### ❌ NEVER Mock
- Database
- Your own services
- Your own modules
- File system operations

## Test Structure (AAA Pattern)

Every test MUST follow Arrange-Act-Assert with these exact comments:

```typescript
it('should create a user with valid data', async () => {
  // Arrange
  const input = { name: 'John Doe', email: 'john@example.com' };

  // Act
  const result = await userService.create(input);

  // Assert
  expect(result.success).toBe(true);
  expect(result.data.name).toBe('John Doe');
});
```

**Rules:**
- Use ONLY `// Arrange`, `// Act`, `// Assert` comments
- NO additional explanations in comments
- Code should be self-explanatory
- Variable/function names must convey intent

| ❌ NEVER | ✅ CORRECT |
|----------|------------|
| `// Arrange: Create a project` | `// Arrange` |
| `// Act: Call the API` | `// Act` |
| `// Assert: Verify response` | `// Assert` |
| `// Arrange - set up data` | `// Arrange` |
| `// Act & Assert: Test fails` | Separate `// Act` and `// Assert` |

## Test Data
- Use faker for random data
- Use factories for database records
- Clean database between tests

## Test Naming
- Describe **behavior**, not implementation
- Use clear, readable names: `should create user with valid email`
- When it helps readability, use consistent prefixes: `inputX`, `mockX`, `expectedX` (e.g. `inputUser`, `mockRepo`, `expectedStatus`).
- **NEVER** reference ticket/task IDs in test names or describe blocks
  - ❌ `describe('User Tests (PROJ-1234)', ...)`
  - ✅ `describe('User Tests', ...)`
- Test descriptions should be timeless and self-explanatory

## File Location
Colocate: `user-service.ts` → `user-service.test.ts`

## API / integration tests (Docker, env)
- Use real services or Docker when testing against local APIs; `.env` for config (e.g. base URL).
- For slow or flaky API tests: set `--testTimeout` (e.g. `120000`) or equivalent in the runner.
- Connection/timeout failures: ensure services are up (e.g. `docker-compose up -d`) or increase timeout.
- Prefer project test layout docs (e.g. ARCHITECTURE.md in the test dir) when present; otherwise colocate and follow AAA.

## E2E (browser / Playwright-style)
- Prefer finding elements by role, label, or text (e.g. `getByRole`, `getByLabel`, `getByText`) instead of complex CSS or XPath; use data-testid or semantic selectors when needed.
- Avoid fixed timeouts; use the runner’s auto-waiting or wait for specific conditions (e.g. element visible, network idle) so tests stay stable.
- Cover critical user journeys; keep each E2E file to a small number of focused tests (e.g. 3–5) and base tests on user stories or common flows.
- Mock external APIs (e.g. Playwright’s `page.route`) when testing UI in isolation so tests are deterministic.
- Run E2E in isolation (no shared state between tests) and in parallel when the runner supports it.

## Cypress (E2E)
- Use `cy.intercept` for API mocking so tests are isolated and deterministic.
- Prefer `data-testid` selectors over CSS or XPath; use `beforeEach` for setup; avoid hard-coded waits.
- Limit each file to 3–5 focused tests; validate both success and error scenarios; base tests on user stories.

## Jest (unit)
- Mock dependencies **before** imports with `jest.mock()`; use `beforeEach` and `jest.clearAllMocks()`.
- Test valid inputs, invalid inputs, and edge cases (null, undefined, wrong types); limit to 3–5 focused tests per file.
- Group tests in `describe` blocks; use clear names that indicate expected behavior.

## Vitest (unit)
- Mock dependencies **before** imports with `vi.mock()`; use `vi.clearAllMocks()` in `beforeEach`.
- Same as Jest: valid/invalid/edge cases, 3–5 tests per file, descriptive names and `describe` grouping.

## API testing (Playwright / Cypress)
- Test critical endpoints: status codes, response body, schema compliance; keep tests isolated and deterministic (no reliance on existing server state).
- Group by endpoint or resource in `describe` blocks; validate both success and error scenarios; use schema validation (e.g. Zod, AJV) when available.
- Limit to 3–5 focused tests per API resource; use fixtures or factories for test data; test authenticated and unauthenticated access where relevant.

## Gherkin / acceptance
- Use Feature, Scenario, Given, When, Then (and And, But); use Examples tables for data-driven scenarios.
- Write in simple, non-technical language so business and legal can read; avoid jargon (API, selector, endpoint).
- When converting technical scripts: Given = preconditions, When = user actions, Then = verifiable outcomes.

## Smoke and Acceptance
- In APIs, consider a smoke endpoint per module (e.g. GET /health or GET /admin/test) for quick sanity checks.
- In acceptance tests, use a Given-When-Then structure in the description or comments so scenarios stay readable.

## When to Run
- After ANY code change → related tests
- Before commit → full test suite
- **Never** commit with failing tests

## Coverage Requirements
- New code: 80%+ coverage (adjust per project)
- Existing code: Do not reduce coverage
