---
description: WebSocket and real-time connection patterns
globs: "**/websocket/**,**/ws/**,**/realtime/**"
alwaysApply: false
---

# WebSocket & Real-Time

## Connection Lifecycle

```
Client                          Server
  │                               │
  ├──── Connect ─────────────────►│
  │                               ├── Authenticate
  │                               ├── Register connection
  │◄──── Connected ───────────────┤
  │                               │
  ├──── Subscribe (topic) ───────►│
  │◄──── Subscribed ──────────────┤
  │                               │
  │◄──── Message ─────────────────┤ (broadcast)
  │◄──── Message ─────────────────┤
  │                               │
  ├──── Ping ────────────────────►│
  │◄──── Pong ────────────────────┤
  │                               │
  ├──── Disconnect ──────────────►│
  │                               ├── Cleanup
```

## Server-Side Patterns

### Connection Management
```
connections: Map<connectionId, {
  socket,
  userId,
  subscribedTopics: Set<string>,
  lastPing: timestamp
}>
```

### Rate Limiting
| Action | Limit | Window |
|--------|-------|--------|
| Connect | 10 | per minute per IP |
| Message | 100 | per minute per connection |
| Subscribe | 50 | per minute per connection |

### Heartbeat Pattern
- Server sends ping every 30 seconds
- Client must respond with pong within 10 seconds
- No response → close connection
- Clean up dead connections periodically

### Backpressure Handling
```
if (socket.bufferedAmount > MAX_BUFFER_SIZE) {
  // Queue message for later
  // Or drop non-critical messages
  // Never block the event loop
}
```

## Horizontal Scaling

### Pub/Sub Pattern
```
┌─────────┐     ┌─────────┐     ┌─────────┐
│ Server1 │     │  Redis  │     │ Server2 │
│         │◄───►│ Pub/Sub │◄───►│         │
│ clients │     │         │     │ clients │
└─────────┘     └─────────┘     └─────────┘
```

### Broadcast Flow
1. Event occurs (e.g., data update)
2. Publish to Redis channel
3. All servers receive message
4. Each server broadcasts to local clients

### Topic/Room Pattern
- Organize connections by topic/room
- Only broadcast to relevant subscribers
- Reduces unnecessary message processing

## Client-Side Patterns

### Reconnection Strategy
```
attempt | delay
   1    | 1s
   2    | 2s
   3    | 4s
   4    | 8s
   5    | 16s
  ...   | max 30s
```

### Connection State
```
enum ConnectionState {
  CONNECTING,
  CONNECTED,
  RECONNECTING,
  DISCONNECTED
}
```

### Message Queue
- Queue messages while disconnected
- Replay on reconnect (if idempotent)
- Discard stale messages

## Message Format

### Structure
```json
{
  "type": "event_type",
  "topic": "channel/room",
  "payload": { ... },
  "timestamp": "ISO-8601",
  "id": "unique-message-id"
}
```

### Types
| Type | Direction | Purpose |
|------|-----------|---------|
| `subscribe` | client→server | Join topic |
| `unsubscribe` | client→server | Leave topic |
| `message` | bidirectional | Data transfer |
| `ping` | client→server | Keep alive |
| `pong` | server→client | Keep alive response |
| `error` | server→client | Error notification |

## Security

### Authentication
- Authenticate on connect (token in query/header)
- Validate token before accepting messages
- Re-authenticate periodically for long connections

### Authorization
- Check permissions per topic subscription
- Validate message permissions
- Don't trust client-sent user IDs

## Monitoring

### Key Metrics
- Active connections count
- Messages per second
- Average message latency
- Connection duration
- Error rate

### Health Checks
- `/health/ws` - WebSocket server status
- Connection count thresholds
- Memory usage (buffer sizes)

## Checklist
- [ ] Authentication on connect
- [ ] Rate limiting implemented
- [ ] Heartbeat mechanism
- [ ] Reconnection with backoff
- [ ] Horizontal scaling strategy
- [ ] Backpressure handling
- [ ] Monitoring in place
