---
description: Python conventions and patterns
globs: "**/*.py,**/requirements.txt,**/pyproject.toml"
alwaysApply: false
---

# Python

## Project Structure

### Standard Layout
```
project/
├── src/
│   └── package_name/
│       ├── __init__.py
│       ├── main.py
│       ├── models/
│       ├── services/
│       ├── api/
│       └── utils/
├── tests/
│   ├── __init__.py
│   ├── conftest.py
│   └── test_*.py
├── pyproject.toml
├── requirements.txt
└── README.md
```

### Package Naming
- All lowercase
- Underscores for separation: `my_package`
- Short and descriptive

## Type Hints

### Always Use Type Hints
```python
from typing import Optional, List, Dict, Any
from datetime import datetime

def get_user(user_id: str) -> Optional[User]:
    """Fetch user by ID."""
    ...

def process_items(items: List[Item]) -> Dict[str, Any]:
    """Process list of items."""
    ...

async def fetch_data(url: str, timeout: float = 30.0) -> bytes:
    """Fetch data from URL."""
    ...
```

### Type Aliases
```python
from typing import TypeAlias

UserId: TypeAlias = str
UserDict: TypeAlias = Dict[str, Any]

def get_user(user_id: UserId) -> UserDict:
    ...
```

### Generic Types
```python
from typing import TypeVar, Generic

T = TypeVar('T')

class Repository(Generic[T]):
    def get(self, id: str) -> Optional[T]:
        ...
    
    def save(self, entity: T) -> T:
        ...
```

## Pydantic Models

### Data Models
```python
from pydantic import BaseModel, Field, EmailStr
from datetime import datetime
from typing import Optional

class UserCreate(BaseModel):
    email: EmailStr
    name: str = Field(..., min_length=1, max_length=100)
    role: str = Field(default="user")

class User(BaseModel):
    id: str
    email: EmailStr
    name: str
    role: str
    created_at: datetime
    
    class Config:
        from_attributes = True  # For ORM compatibility

class UserResponse(BaseModel):
    data: User
    meta: Dict[str, Any] = Field(default_factory=dict)
```

### Validation
```python
from pydantic import BaseModel, field_validator

class OrderCreate(BaseModel):
    amount: float
    currency: str
    
    @field_validator('amount')
    @classmethod
    def amount_must_be_positive(cls, v: float) -> float:
        if v <= 0:
            raise ValueError('amount must be positive')
        return v
    
    @field_validator('currency')
    @classmethod
    def currency_must_be_valid(cls, v: str) -> str:
        valid_currencies = {'USD', 'EUR', 'GBP'}
        if v.upper() not in valid_currencies:
            raise ValueError(f'currency must be one of {valid_currencies}')
        return v.upper()
```

## Error Handling

### Custom Exceptions
```python
class AppError(Exception):
    def __init__(self, code: str, message: str, status_code: int = 400):
        self.code = code
        self.message = message
        self.status_code = status_code
        super().__init__(message)

class NotFoundError(AppError):
    def __init__(self, resource: str, id: str):
        super().__init__(
            code="NOT_FOUND",
            message=f"{resource} with id {id} not found",
            status_code=404
        )

class ValidationError(AppError):
    def __init__(self, message: str):
        super().__init__(
            code="VALIDATION_ERROR",
            message=message,
            status_code=422
        )
```

### Exception Handling
```python
def get_user(user_id: str) -> User:
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise NotFoundError("User", user_id)
        return user
    except SQLAlchemyError as e:
        logger.error(f"Database error: {e}")
        raise AppError("DATABASE_ERROR", "Failed to fetch user", 500)
```

## Async Patterns

### Async Functions
```python
import asyncio
from typing import List

async def fetch_user(user_id: str) -> User:
    async with aiohttp.ClientSession() as session:
        async with session.get(f"/users/{user_id}") as response:
            data = await response.json()
            return User(**data)

async def fetch_users(user_ids: List[str]) -> List[User]:
    tasks = [fetch_user(uid) for uid in user_ids]
    return await asyncio.gather(*tasks)
```

### Context Managers
```python
from contextlib import asynccontextmanager

@asynccontextmanager
async def get_db_session():
    session = AsyncSession(engine)
    try:
        yield session
        await session.commit()
    except Exception:
        await session.rollback()
        raise
    finally:
        await session.close()

# Usage
async with get_db_session() as session:
    user = await session.get(User, user_id)
```

## Testing with pytest

### Test Structure
```python
import pytest
from unittest.mock import Mock, patch

class TestUserService:
    @pytest.fixture
    def user_service(self):
        repo = Mock()
        return UserService(repo)
    
    @pytest.fixture
    def sample_user(self):
        return User(id="1", email="test@example.com", name="Test")
    
    def test_get_user_success(self, user_service, sample_user):
        # Arrange
        user_service.repo.find_by_id.return_value = sample_user
        
        # Act
        result = user_service.get_user("1")
        
        # Assert
        assert result == sample_user
        user_service.repo.find_by_id.assert_called_once_with("1")
    
    def test_get_user_not_found(self, user_service):
        # Arrange
        user_service.repo.find_by_id.return_value = None
        
        # Act & Assert
        with pytest.raises(NotFoundError):
            user_service.get_user("invalid")
```

### Fixtures
```python
# conftest.py
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

@pytest.fixture(scope="session")
def engine():
    return create_engine("sqlite:///:memory:")

@pytest.fixture(scope="function")
def db_session(engine):
    Session = sessionmaker(bind=engine)
    session = Session()
    yield session
    session.rollback()
    session.close()

@pytest.fixture
def user_factory():
    def _create_user(**kwargs):
        defaults = {
            "email": "test@example.com",
            "name": "Test User",
        }
        return User(**{**defaults, **kwargs})
    return _create_user
```

### Parametrized Tests
```python
@pytest.mark.parametrize("input,expected", [
    ("hello", "HELLO"),
    ("world", "WORLD"),
    ("", ""),
])
def test_uppercase(input, expected):
    assert input.upper() == expected
```

## FastAPI Patterns

### Router Structure
```python
from fastapi import APIRouter, Depends, HTTPException, status

router = APIRouter(prefix="/users", tags=["users"])

@router.get("/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: str,
    service: UserService = Depends(get_user_service),
):
    try:
        user = await service.get_user(user_id)
        return UserResponse(data=user)
    except NotFoundError:
        raise HTTPException(status_code=404, detail="User not found")

@router.post("/", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
async def create_user(
    user_data: UserCreate,
    service: UserService = Depends(get_user_service),
):
    user = await service.create_user(user_data)
    return UserResponse(data=user)
```

### Dependency Injection
```python
from functools import lru_cache

@lru_cache
def get_settings():
    return Settings()

def get_db_session():
    session = SessionLocal()
    try:
        yield session
    finally:
        session.close()

def get_user_service(
    session: Session = Depends(get_db_session),
    settings: Settings = Depends(get_settings),
) -> UserService:
    repo = UserRepository(session)
    return UserService(repo, settings)
```

## Best Practices

### Do
- Use type hints everywhere
- Use Pydantic for data validation
- Use pytest fixtures for test setup
- Use async for I/O operations
- Use `__all__` for public exports
- Document with docstrings

### Don't
- Use mutable default arguments
- Catch bare `Exception`
- Use `global` variables
- Mix sync and async carelessly
- Ignore type checker warnings

## Checklist
- [ ] Type hints on all functions
- [ ] Pydantic models for data
- [ ] Custom exceptions defined
- [ ] Tests with pytest
- [ ] Async where appropriate
- [ ] Dependencies injected
