---
description: HTMX with backend (Go, Flask, Django)
globs: "**/*.html"
alwaysApply: false
---

# HTMX

## Attributes
- Use `hx-get` for GET requests; `hx-post` for POST; `hx-put`, `hx-patch`, `hx-delete` for other methods.
- Use `hx-trigger` for when to fire (e.g. `click`, `change`, `submit`); use `hx-swap` to control how content is replaced (`innerHTML`, `outerHTML`, `beforeend`, etc.).
- Use `hx-target` to specify where to swap content (default: current element); use `hx-indicator` for loading indicators.

## Best Practices
- Prefer partial HTML responses from the server (fragments) instead of full pages; use `HX-Request` header to detect HTMX requests and return fragments.
- Use `hx-boost` on containers for progressive enhancement (links/forms work without JS); use `hx-headers` to send extra headers.
- Keep backend endpoints returning HTML fragments; use consistent layout (e.g. Django templates, Go html/template, Flask Jinja) so swap targets are predictable.

## Backend
- With Go: use standard library or Fiber; structure handlers to return HTML fragments; use middleware for logging/CSRF.
- With Django: use class-based or function-based views; return `render(..., partial=True)` or fragment templates when `HX-Request`.
- With Flask: return `render_template` of a fragment; check `request.headers.get('HX-Request')` to decide full page vs fragment.
