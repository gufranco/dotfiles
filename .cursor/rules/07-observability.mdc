---
description: Observability, tracing, and monitoring patterns
globs: "**/*.ts,**/*.tsx"
alwaysApply: false
---

# Observability

## Distributed Tracing

### Request Context
Every request MUST have a unique identifier propagated through all operations:

```typescript
interface RequestContext {
  requestId: string;
  userId?: string;
  companyId?: string;
  startTime: number;
}
```

### Propagation Rules
- Generate `requestId` at API entry point (middleware)
- Pass through all service method calls
- Include in all log entries
- Send to external APIs via headers (`X-Request-ID`)
- Return in error responses

## Health Checks

### Endpoints
| Endpoint | Purpose | Checks |
|----------|---------|--------|
| `GET /health` | Liveness | Always returns 200 |
| `GET /health/ready` | Readiness | DB + Redis connected |

### Implementation
```typescript
// Liveness - always healthy if process is running
app.get('/health', () => ({ status: 'ok' }));

// Readiness - check dependencies
app.get('/health/ready', async () => {
  const db = await checkDatabase();
  const redis = await checkRedis();
  
  if (!db || !redis) {
    return { status: 503, checks: { db, redis } };
  }
  return { status: 'ok', checks: { db, redis } };
});
```

## Metrics

### Key Metrics to Track
| Category | Metric | Alert Threshold |
|----------|--------|-----------------|
| Latency | p50, p95, p99 response time | p95 > 500ms |
| Errors | Error rate by endpoint | > 1% |
| Throughput | Requests per second | Baseline Â±50% |
| Saturation | CPU, memory usage | > 80% |

### Business Metrics
- Active users per company
- Work orders created/completed
- API usage by endpoint
- Cache hit/miss ratio

## Alerting Thresholds

| Metric | Warning | Critical |
|--------|---------|----------|
| Error rate | > 1% | > 5% |
| p95 latency | > 500ms | > 1s |
| p99 latency | > 1s | > 3s |
| Cache miss rate | > 20% | > 40% |
| DB connection pool | > 70% | > 90% |

## Structured Logging for Tracing

### Log Context
Always include these fields:

```typescript
logger.info({
  requestId: ctx.requestId,
  userId: ctx.userId,
  companyId: ctx.companyId,
  operation: 'createWorkOrder',
  duration: Date.now() - ctx.startTime,
  // operation-specific data
});
```

### External Call Logging
```typescript
logger.info({
  requestId: ctx.requestId,
  externalService: 'resend',
  operation: 'sendEmail',
  duration: 150,
  success: true,
});
```

## Performance Budgets

| Operation | Target | Max |
|-----------|--------|-----|
| API response | < 100ms | 500ms |
| Database query | < 50ms | 200ms |
| Cache read | < 5ms | 20ms |
| External API | < 500ms | 3s |

## Route Metadata Pattern

### Tagging Routes for Observability
```typescript
// Define metadata for each route
interface RouteMetadata {
  controller: string;
  service: string;
  operation: string;
}

// Middleware to attach metadata
function withMetadata(metadata: RouteMetadata) {
  return (req, res, next) => {
    req.routeMetadata = metadata;
    next();
  };
}

// Usage in routes
router.post('/users', 
  withMetadata({
    controller: 'UserController',
    service: 'UserService',
    operation: 'createUser'
  }),
  userController.create
);
```

### Benefits
- Automatic tagging in APM tools (Datadog, New Relic)
- Better log grouping
- Easier debugging and filtering
- Performance analysis per controller/service

### Logging Middleware
```typescript
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    logger.info({
      requestId: req.requestId,
      method: req.method,
      path: req.path,
      status: res.statusCode,
      duration: Date.now() - start,
      // Route metadata
      controller: req.routeMetadata?.controller,
      service: req.routeMetadata?.service,
      operation: req.routeMetadata?.operation,
    });
  });
  
  next();
});
```

## Debugging Checklist

When investigating issues:
1. Get `requestId` from error response or logs
2. Search logs by `requestId`
3. Filter by controller/service/operation
4. Check external service logs (same `requestId`)
5. Review timing breakdown
6. Check cache hit/miss
7. Review database query plans

## Rules
- Every request MUST have a `requestId`
- Tag routes with metadata for better observability
- Log entry and exit of critical operations
- Include duration for all async operations
- Never log sensitive data (passwords, tokens, PII)
- Set up alerts before going to production
