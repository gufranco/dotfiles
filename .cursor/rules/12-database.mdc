---
description: Database and Prisma patterns
globs: "**/*.prisma,**/prisma/**,**/repositories/**"
alwaysApply: false
---

# Database

## Official Documentation
Always consult before implementing:
- Prisma Docs: https://www.prisma.io/docs
- Query Optimization: https://www.prisma.io/docs/guides/performance-and-optimization
- Connection Management: https://www.prisma.io/docs/guides/performance-and-optimization/connection-management

## ORM Rules
- **NEVER** use raw SQL (`$queryRaw`, `$executeRaw`)
- Use transactions for data modifications
- Use `SELECT ... FOR UPDATE` for reads before writes

## Schema
- Always: `created_at`, `updated_at`
- Soft delete: `deleted_at` (nullable)
- Dates in UTC

## Query Optimization
- No `SELECT *` → specify columns
- No N+1 → use `include`/eager loading
- Pagination for lists
- Indexes for WHERE, JOIN, ORDER BY

## Safe Migrations
| Operation | Approach |
|-----------|----------|
| Add column | Nullable first → backfill → constraint |
| Remove column | Stop reading → deploy → remove |
| Rename column | Add new → copy → migrate code → remove old |
| Add index | `CONCURRENTLY` |

## Naming
Tables: `plural_snake_case`
Columns: `singular_snake_case`
FK: `<table>_id`

## Index Requirements
Always create indexes for:
- Foreign keys (Prisma does this automatically)
- Columns used in WHERE clauses
- Columns used in ORDER BY
- Columns used in JOIN conditions
- Unique constraints

```prisma
model User {
  email String @unique
  
  @@index([companyId])
  @@index([email])
  @@index([createdAt])
}
```

## Multi-tenant Queries
**Every** query MUST filter by `companyId`:
```typescript
// ✅ Correct
prisma.client.findMany({ where: { companyId } })

// ❌ Wrong - data leak risk
prisma.client.findMany()
```

## Prisma Extensions

### Query Logging Extension
```typescript
import { Prisma } from '@prisma/client';

const queryLoggingExtension = Prisma.defineExtension({
  query: {
    $allOperations({ operation, model, args, query }) {
      const start = Date.now();
      
      return query(args).finally(() => {
        const duration = Date.now() - start;
        logger.debug({
          model,
          operation,
          duration,
          // Include requestId from AsyncLocalStorage
          requestId: getRequestId(),
        });
      });
    },
  },
});
```

### Read Replicas Extension
```typescript
import { readReplicas } from '@prisma/extension-read-replicas';

const prisma = new PrismaClient().$extends(
  readReplicas({
    url: process.env.DATABASE_REPLICA_URL,
  })
);

// Reads go to replica, writes to primary
const users = await prisma.user.findMany(); // → replica
const user = await prisma.user.create({ data }); // → primary
```

### Soft Delete Extension
```typescript
const softDeleteExtension = Prisma.defineExtension({
  query: {
    $allModels: {
      async findMany({ model, args, query }) {
        args.where = { ...args.where, deletedAt: null };
        return query(args);
      },
      async delete({ model, args, query }) {
        return prisma[model].update({
          ...args,
          data: { deletedAt: new Date() },
        });
      },
    },
  },
});
```

### Usage
```typescript
// Compose extensions
const prisma = new PrismaClient()
  .$extends(queryLoggingExtension)
  .$extends(readReplicas({ url: replicaUrl }))
  .$extends(softDeleteExtension);
```

## Connection Pooling

### Pool Sizing Formula
```
Pool Size = (Number of Cores × 2) + Effective Spindle Count
```

For serverless: Use connection pooling service (PgBouncer, Prisma Data Proxy)

### Configuration
```
DATABASE_URL="postgresql://...?connection_limit=10&pool_timeout=20"
```
