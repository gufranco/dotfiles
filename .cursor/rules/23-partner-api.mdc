---
description: Partner/B2B API authentication and security
globs: "**/partner/**,**/webhook/**,**/api/**"
alwaysApply: false
---

# Partner & B2B API

## Authentication Methods

### API Key
```
Header: X-API-Key: <your-api-key>
```
- Simple, low-security use cases
- Rate limit by key
- Rotate periodically

### HMAC Signature
```
Header: X-Signature: sha256=<signature>
Header: X-Timestamp: <unix-timestamp>
```
- High-security use cases
- Proves request integrity
- Prevents replay attacks

### OAuth2 Client Credentials
```
POST /oauth/token
grant_type=client_credentials
client_id=xxx
client_secret=xxx
```
- Complex integrations
- Scoped permissions
- Token expiration

## HMAC Signature Pattern

### Signing (Partner Side)
```typescript
function signRequest(
  method: string,
  path: string,
  body: string,
  secret: string
): { signature: string; timestamp: string } {
  const timestamp = Math.floor(Date.now() / 1000).toString();
  const payload = `${timestamp}.${method}.${path}.${body}`;
  
  const signature = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex');
  
  return { signature: `sha256=${signature}`, timestamp };
}
```

### Verification (Server Side)
```typescript
function verifySignature(
  method: string,
  path: string,
  body: string,
  signature: string,
  timestamp: string,
  secret: string
): boolean {
  // 1. Check timestamp (prevent replay)
  const now = Math.floor(Date.now() / 1000);
  const requestTime = parseInt(timestamp);
  if (Math.abs(now - requestTime) > 300) { // 5 minutes
    return false;
  }
  
  // 2. Compute expected signature
  const payload = `${timestamp}.${method}.${path}.${body}`;
  const expected = `sha256=${crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex')}`;
  
  // 3. Constant-time comparison
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expected)
  );
}
```

## Request Requirements

### Required Headers
| Header | Purpose |
|--------|---------|
| `X-API-Key` or `Authorization` | Authentication |
| `X-Signature` | Request integrity (HMAC) |
| `X-Timestamp` | Replay protection |
| `X-Idempotency-Key` | Safe retries |
| `Content-Type` | Always `application/json` |

### Body Integrity
```typescript
// Include body hash in signature for extra security
const bodyHash = crypto
  .createHash('sha256')
  .update(body)
  .digest('hex');
```

## Webhook Delivery

### Outbound Webhooks
1. Sign every webhook request
2. Include event ID for idempotency
3. Implement retry with backoff
4. Dead letter queue after max retries

### Retry Schedule
| Attempt | Delay |
|---------|-------|
| 1 | Immediate |
| 2 | 1 minute |
| 3 | 5 minutes |
| 4 | 30 minutes |
| 5 | 2 hours |
| 6+ | Dead letter |

### Webhook Payload
```json
{
  "id": "evt_abc123",
  "type": "resource.event",
  "timestamp": "2024-01-15T10:30:00Z",
  "data": { ... },
  "signature": "sha256=..."
}
```

## Partner Onboarding

### Checklist
- [ ] Generate API credentials
- [ ] Share webhook signing secret
- [ ] Configure allowed IPs (if applicable)
- [ ] Set rate limits
- [ ] Test webhook delivery
- [ ] Provide API documentation
- [ ] Set up monitoring/alerts

### Credential Management
- Generate unique credentials per partner
- Store secrets securely (encrypted)
- Support credential rotation
- Audit credential usage

## Security Best Practices

### Do
- Use HTTPS only
- Validate all inputs
- Log all API calls (without secrets)
- Implement rate limiting
- Use constant-time comparison for signatures
- Set appropriate CORS headers

### Don't
- Log secrets or signatures
- Trust client-provided timestamps without validation
- Skip signature verification
- Expose internal errors
- Allow unlimited retries

## IP Allowlisting (Optional)

```typescript
const allowedIPs = partner.allowedIPs; // ['1.2.3.4', '5.6.7.8']

if (allowedIPs.length > 0 && !allowedIPs.includes(clientIP)) {
  return res.status(403).json({ error: 'IP not allowed' });
}
```

## Monitoring

### Key Metrics
- Requests per partner
- Error rate per partner
- Webhook delivery success rate
- Average response time
- Authentication failures

### Alerts
- Spike in authentication failures
- Webhook delivery failures
- Unusual request patterns
- Rate limit exceeded

## Checklist
- [ ] Authentication method chosen
- [ ] Signature verification implemented
- [ ] Replay protection (timestamp validation)
- [ ] Rate limiting per partner
- [ ] Webhook retry mechanism
- [ ] Audit logging
- [ ] Documentation provided
